<html>
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Editing Basic Tutorial Creating List with Live Filtering - JSX Edition</title>
  <meta name="description" content="A library providing an abstraction for React components that allows for fast top-down rendering embracing immutable data for js.
">

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/kimbie.dark.min.css">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://omniscientjs.github.io//tutorials/02-editing-basic-tutorial-creating-list-with-live-filtering-jsx-edition/">
  <link rel="alternate" type="application/rss+xml" title="Omniscient.js" href="http://omniscientjs.github.io//feed.xml" />

  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
</head>

  <body class="withSmallHeader">
    <header class="mainHeader mainHeader--small">
      <nav class="mainNavigation">
  <div class="mainNavigation-inner">
    <h1>
      <a href="/">
        <svg width="50px" height="25px" viewBox="0 0 600 400" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg" preserveAspectRatio="xMinYMax meet">
         <g>
          <title>Layer 1</title>
          <path fill="black" d="m416.873962,103.126556c25.875885,25.8759 40.126068,60.279999 40.126068,96.873978s-14.250702,70.997604 -40.126068,96.873428c-25.876404,25.875366 -60.279999,40.126038 -96.873932,40.126038s-70.997589,-14.250671 -96.873993,-40.126038c-25.875351,-25.875824 -40.126053,-60.279449 -40.126053,-96.873428s14.249634,-70.998093 40.126053,-96.873978s60.279968,-40.126556 96.873993,-40.126556s70.997528,14.250671 96.873932,40.126556zm-12.109436,181.638428c16.872894,-16.872925 28.091919,-37.891312 32.717834,-60.756882c-3.605408,5.307693 -7.054443,7.277054 -9.189819,-4.603958c-2.199463,-19.37001 -19.990173,-6.996109 -31.177582,-13.876587c-11.774506,7.935806 -38.238556,-15.429062 -33.741058,10.923599c6.939331,11.886398 37.463074,-15.908005 22.248596,9.242767c-9.706177,17.557953 -35.492126,56.44072 -32.137756,76.596359c0.423279,29.365082 -30.004639,6.12323 -40.488342,-3.617737c-7.052277,-19.511749 -2.403381,-53.616165 -20.843781,-63.171387c-20.015381,-0.869095 -37.194427,-2.68811 -44.951538,-25.064056c-4.668152,-16.008682 4.967316,-39.84079 22.122833,-43.519989c25.112213,-15.77803 34.082458,18.477341 57.633636,19.114182c7.312408,-7.651138 27.243744,-10.083954 28.896362,-18.663574c-15.452667,-2.726624 19.604858,-12.993073 -1.479218,-18.832657c-11.631653,1.367828 -19.125916,12.060776 -12.942749,21.127396c-22.540314,5.255783 -23.262207,-32.61879 -44.929047,-20.672546c-0.550659,18.888336 -35.379791,6.123779 -12.05069,2.293671c8.015564,-3.502045 -13.073914,-13.650772 -1.680359,-11.806595c5.596619,-0.303986 24.438416,-6.906754 19.339447,-11.345871c10.49176,-6.512856 19.308472,15.597137 29.577576,-0.503555c7.414032,-12.379776 -3.109314,-14.665443 -12.402313,-8.390175c-5.239136,-5.866417 9.250214,-18.536766 22.030273,-24.011932c4.259308,-1.824898 8.327606,-2.819214 11.437988,-2.537704c6.437317,7.436531 18.342377,8.72464 18.965332,-0.894264c-15.942291,-7.635071 -33.520569,-11.668556 -51.720123,-11.668556c-26.121552,0 -50.965668,8.301338 -71.525818,23.651237c5.525497,2.531273 8.662079,5.682831 3.338867,9.712013c-4.135681,12.323067 -20.91658,28.865273 -35.647858,26.52343c-7.648972,13.190521 -12.686386,27.722687 -14.839874,42.953796c12.338593,4.082153 15.183472,12.161407 12.532303,14.863937c-6.287018,5.482147 -10.150848,13.253189 -12.141647,21.760544c4.016357,24.573288 15.565536,47.220566 33.519516,65.175095c22.641373,22.640869 52.744461,35.109924 84.764511,35.109924c32.01944,0 62.123016,-12.469116 84.764496,-35.109924l0,0z" id="svg_7" stroke="null"/>
          <path fill="black" id="svg_4" d="m320,5.3125c-194.6875,0 -311.5,193.480423 -311.5,193.480423s116.8125,195.894577 311.5,195.894577s311.5,-194.6875 311.5,-194.6875s-116.8125,-194.6875 -311.5,-194.6875zm0,350.4375c-170.351563,0 -262.828125,-155.75 -262.828125,-155.75s92.476563,-155.75 262.828125,-155.75s262.828125,155.75 262.828125,155.75s-92.476563,155.75 -262.828125,155.75z"/>
         </g>
        </svg>
      </a>
    </h1>

    <ul>
      <li><a href="/guides">Guides</a></li>
      <li><a href="/api">API</a></li>
      <li><a href="/tutorials">Tutorials</a></li>
    </ul>
  </div>
</nav>
    </header>

    <main class="mainContent js-tutorials-content" id="content">
      <div class="nav-left">
  
    <div class="guides-left-collection">
      <h3><a href="/guides">Guides</a></h3>
      <ol>
        
        
        
        
          <li>
            <a href="/guides/01-simpler-ui-reasoning-with-unidirectional">Simpler UI Reasoning with Unidirectional Dataflow and Immutable Data</a>
          </li>
        
        
        
          <li>
            <a href="/guides/02-editing-using-immutable-cursors-with-omniscient">Editing Using Immutable Cursors with Omniscient</a>
          </li>
        
        
      </ol>
    </div>
  
    <div class="guides-left-collection">
      <h3><a href="/tutorials">Tutorials</a></h3>
      <ol>
        
        
        
        
          <li>
            <a href="/tutorials/01-editing-basic-tutorial-creating-list-with-live-filtering">Editing Basic Tutorial Creating List with Live Filtering</a>
          </li>
        
        
        
          <li>
            <a href="/tutorials/02-editing-basic-tutorial-creating-list-with-live-filtering-jsx-edition">Editing Basic Tutorial Creating List with Live Filtering - JSX Edition</a>
          </li>
        
        
      </ol>
    </div>
  
</div>

      <section class="column" id="content">
        <h1>
  Editing Basic Tutorial Creating List with Live Filtering - JSX Edition
  <a class="edit-page-link" href="https://github.com/omniscientjs/omniscient/tree/master/_tutorials/02-editing-basic-tutorial-creating-list-with-live-filtering-jsx-edition.md" target="_blank">Edit on GitHub</a>
</h1>

<div class="subHeader"></div>

<p>If you haven’t read the Omniscient introduction article yet, you should probably <a href="http://open.bekk.no/easier-reasoning-with-unidirectional-dataflow-and-immutable-data">read it before you get started</a> on this tutorial. The previous article in this series introduces the concepts and architecture. In this example, we will see how we can use <a href="https://github.com/facebook/react">React</a>, <a href="https://github.com/omniscientjs/omniscient">Omniscient.js</a>, and <a href="https://github.com/facebook/immutable-js">Immutable.js</a> to build a rudimentary filtering-based search application. You can see a <a href="http://omniscientjs.github.io/examples/#search">running demo on the Omniscient homepage</a>, and the <a href="https://gist.github.com/mikaelbr/d54ad8871c79d15049d3">complete source code as a Gist</a>. After we’ve implemented the example, we’ll look into how we can debug an Omniscient application, and see what components get re-rendered.</p>

<p><em>Note: This tutorial is intended for React <code>v0.12.0</code> and Omniscient <code>v2.0.0</code>.</em></p>

<p>For this example, we’re creating a small application where we can search for different javascript libraries and frameworks from a list. We should start by requiring the modules we want to use. A basic stack with Omniscient consists of React, immstruct (which wraps Immutable.js) and of course Omniscient itself.</p>

<pre><code class="language-js">var React     = require('react'),
    immstruct = require('immstruct'), // wrapped Immutable.js
    component = require('omniscient');
</code></pre>

<p>To show a list of different javascript projects, we should have a top structure with our data defined as a immutable structure. We need a list of different projects and their URLs, but also a string which will be the current search query, that will behave as an active filter. The entire application state is defined in that structure alone. If we wanted, we could have started the application with a predefined search instead of an empty string – making it easier to test and demo.</p>

<pre><code class="language-js">var structure = immstruct({
  search: '',
  libs: [
    { title: 'Backbone.js', url: 'http://documentcloud.github.io/backbone/' },
    { title: 'AngularJS', url: 'https://angularjs.org/' },
    { title: 'jQuery', url: 'http://jquery.com/' },
    { title: 'Prototype', url: 'http://www.prototypejs.org/' },
    { title: 'React', url: 'http://facebook.github.io/react/' },
    { title: 'Omniscient', url: 'https://github.com/omniscientjs/omniscient' },
    { title: 'Ember', url: 'http://emberjs.com/' },
    { title: 'Knockout.js', url: 'http://knockoutjs.com/' },
    { title: 'Dojo', url: 'http://dojotoolkit.org/' },
    { title: 'Mootools', url: 'http://mootools.net/' },
    { title: 'Underscore', url: 'http://documentcloud.github.io/underscore/' },
    { title: 'Lodash', url: 'http://lodash.com/' },
    { title: 'Moment', url: 'http://momentjs.com/' },
    { title: 'Express', url: 'http://expressjs.com/' },
    { title: 'Koa', url: 'http://koajs.com' },
  ]
});
</code></pre>

<p>We could also load the data lazily. This is an operation that shouldn’t be a part of our UI, but rather of a separate module handling models and collections. We could send a cursor to where we want the data populated, using Immutable.js. For instance:</p>

<pre><code class="language-js">var storage = require('./storage');

var structure = immstruct({
  search: '',
  libs: [ ]
});

// fetchLibraries could use AJAX; it swaps the empty libs list
// in our structure to a new one containing the new models.
storage.fetchLibraries(structure.cursor('libs'));
</code></pre>

<p>There would’t be any need for doing anything else: if our <code>fetchLibraries</code> method swapped the value in our structure, we would get an event from <code>immstruct</code> telling us that a value has been swapped in the data structure. We should re-render if this happens.</p>

<p>The code for rendering the application starts like this:</p>

<pre><code class="language-js">function render () {
  React.render(
    &lt;Search.jsx cursor={structure.cursor()} /&gt;,
    document.body
  );
}

render();
structure.on('swap', render);
</code></pre>

<p>Remember, <code>structure</code> is the immutable structure we created to hold the application data. It emits event, <code>swap</code> (this feature comes from immstruct), when this event is emitted; in response, we will want to re-render the entire component tree, starting with a top parent component. Let’s call it <code>Search</code> in this example.</p>

<p>You may have noticed the <code>.jsx</code> suffix to <code>Search</code> in the render-function. This is different than <a href="https://github.com/omniscientjs/omniscient/wiki/Basic-Tutorial:-Creating-List-with-Live-Filtering">using non-JSX</a>. This is to get the actual component, and not the returned element. JSX compiles this file and converts the Component to an element, but when you use Omniscient with JSX, you need to retrieve the actual React component, hence the suffix. You could also do something like:</p>

<pre><code class="language-js">Search = Search.jsx;
</code></pre>

<p>And after this point, <code>Search</code> would always be JSX-compatible component.</p>

<p>Now, let us start implementing <code>Search</code>, which will consist of a <code>SearchBox</code> and a set of <code>Matches</code>. This is pretty straightforward: we are simply making HTML elements and describing our view in a declarative way, using components. Much like doing… HTML markup:</p>

<pre><code class="language-js">var Search = component('Search', function (props) {
  return (
    &lt;div&gt;
      &lt;SearchBox.jsx cursor={props.cursor.cursor('search')} /&gt;
      &lt;Matches.jsx cursor={props.cursor} /&gt;
    &lt;/div&gt;
  );
});
</code></pre>

<p>As we see, a component is created using Omniscient’s <code>component</code> function. Its first argument is a string representation of the component and is used for debugging as well as the component’s name in React. The second argument is the component implementation itself, provided as a function. This function is a render* function: it returns a React element (here, a div). When a component should render, this *render function is executed, and its return value will be the representation of the component. The render function of a component is passed a cursor, which is the cursor a parent component (or the top renderer) is serving. In our case, <code>Search</code> being the top-level component, it will get passed an object literal with a property of our cursor to the entire application state: <code>structure.cursor()</code>, as defined in our main <code>render</code> helper function above.</p>

<p>As we can see, <code>Search</code> is a small component that actually outputs a combination of two sub-components: <code>SearchBox</code> and <code>Matches</code>. The empty object as first argument to the React div-element is HTML metadata to the div. We see that <code>Matches</code> gets the same cursor <code>Search</code> has (a cursor to the entire structure), as it needs a representation of the entire state, but <code>SearchBox</code> only needs information about the search query, hence the “sub-cursor” to “search” (it should not concern itself with how the list is stored, handled or what it contains).</p>

<p>The next natural step is to list out all the matches based on the search query, which is the main feature of our application. We don’t have any way of altering the search query yet, but that doesn’t matter. We have the search query as a value inside our global application state, and with it being empty, we should list out <em>all</em> our javascript projects.</p>

<p>A list of matches consist in a list of <code>Match</code> components. <code>Match</code> will be a component that merely presents a javascript library as a list item, with an anchor-element to open the library’s homepage, like so:</p>

<pre><code class="language-js">var Match = component('Match', function (props) {
  var cursor = props.cursor;
  return (
    &lt;li&gt;
      &lt;a href={cursor.get('url')}&gt;{cursor.get('title')}&lt;/a&gt;
    &lt;/li&gt;
  );
});
</code></pre>

<p>The <code>Matches</code> component (the list of matches) is far more interesting, and is the heart of the application. To do its work, it needs: the search query, the list of projects, and a way to filter the projects based on the search query. The matches should be presented to the browser as an un-ordered list of elements.</p>

<pre><code class="language-js">var Matches = component('Matches', function (props) {
  // get our cursor from the properties.
  var cursor = props.cursor;

  // Get the value from search query
  var q = cursor.get('search');

  // Get all projects
  var libs = cursor.get('libs');

  // Get all javascript projects that matches the query
  var matches = libs.filter(function (lib) {
    return lib.get('title').indexOf(q) !== -1 || lib.get('url').indexOf(q) !== -1;
  });

  // Present the matches
  return (
    &lt;ul&gt;
      {matches.toArray().map(function (lib, i) {
        return (
          &lt;Match.jsx key={'match-' + lib.get('title')}
            cursor={lib} /&gt;
        );
      })}
    &lt;/ul&gt;
  );
});
</code></pre>

<p>Even this, the main part of our application, shouldn’t do anything that is not related to the presentation. We only want to present the items that match our search query, so we filter the list of libraries to select those that contains our search query (either in the name or the URL) and present them in the returned element. If we try to change our initial search query, like so:</p>

<pre><code class="language-js">var structure = immstruct({
  search: 'Omniscient',
  // ...
});
</code></pre>

<p>… and refresh the browser, we would see only the Omniscient library being presented in the list. And every time we refresh the browser, this is what we would see. Pure, predictable components.</p>

<p>Ok, but altering the source code and refreshing the browser isn’t really user friendly - nor fast. We should create a separate component for updating the search query, the infamous search box:</p>

<pre><code class="language-js">var SearchBox = component('SearchBox', function (props) {
  return (
    &lt;div&gt;
      &lt;input placeholder="Search.."
             value={props.cursor.deref()}
             onChange={this.changeHandler} /&gt;
    &lt;/div&gt;
  );
});
</code></pre>

<p>The <code>SearchBox</code> component should be an easy one, but we can see two things here that might be new. The cursor we get passed in the props is a cursor that <em>directly</em> references the search string. To get that string, for there is no <code>get</code> function as we used earlier (to get nested properties), we instead need to de-reference the cursor by calling <code>props.cursor.deref()</code>. Another thing here is the <code>changeHandler</code>. We have seen an event handler previously, but not the <code>onChange</code> thing. <code>onChange</code> is triggered every time the input is changed (but not blurred, as one might expect).</p>

<p>Let’s create a small mixin that can handle this kind of change for us. As this is javascript and we have lexical scoping, we can easily share a context with the component through <code>this</code> when using the mixin from within the component. The passed cursor will be available through the property <code>this.props.cursor</code> inside the mixin, as expected, and in that case, the cursor points directly to the search query in the structure, so we can update it right away:</p>

<pre><code class="language-js">var mixins = {
  changeHandler: function (e) {
    this.props.cursor.update(function (currentSearch) {
      // We don't actually need the current value (currentSearch),
      // let's just replace it!
      return e.currentTarget.value;
    });
  }
};

// Change our SearchBox from above to add the mixins
var SearchBox = component('SearchBox', mixins, function (props) { /* same as before */ });

</code></pre>

<p>The <code>changeHandler</code> has one small job: to update the cursor with the new value of the input box. This will swap the search query in the immutable structure and, through immstruct’s swap event, tell the application to re-render.</p>

<p>That is it! That, is our entire live filter application. It is pretty awesome and really easy to reason about - almost as simple as HTML itself. Check out the <a href="https://gist.github.com/mikaelbr/d54ad8871c79d15049d3">complete source code as a Gist</a>.</p>

<p>To wrap it up, let’s review what is <em>happening</em> here. What does <em>happen</em> when we re-render? And, just for the sake of it, how do we debug things?</p>

<h3 id="analyzing-re-renders">Analyzing re-renders</h3>

<p>The re-render process is interesting. We will go through it, top-down, to see if the components have changed and how the react. So, when a new input is registered in our text field, the <code>onChange</code> handler kicks in and we swap out the search query value in our immutable structure, which causes a “swap” event to be emitted. As we are listening for such events, it triggers a re-render of the root component. Let’s check whether the cursor passed to <code>Search</code> has changed:</p>

<pre><code class="language-js">React.render(
  &lt;Search.jsx cursor={structure.cursor()} /&gt;,
  document.body
);
</code></pre>

<p>It has changed indeed, because the object has changed somehow and this is a cursor to the whole object. So, we actually do a re-render. The component’s render function is executed, and as it creates two sub-components, we again check whether <code>SearchBox</code> and <code>Matches</code>’ cursors have changed. Both have changed, as both have access to the search query and the search query has changed, so we trigger a re-render of both components. The search box simply renders out the new updated state to the browser, whereas the <code>Matches</code> list generates a new list of sub-components by filtering all javascript projects based on the search query.</p>

<p>We can activate the Omniscient debugger to better see what happens next:</p>

<pre><code class="language-js">// Activate debug-mode
component.debug();
</code></pre>

<p>While having the debug-mode activated, let’s try to go from <code>e</code> to <code>en</code> in the input box. We should get 4 results. The debug output is:</p>

<pre><code>&lt;Search&gt;: shouldComponentUpdate =&gt; true (cursors have changed)
&lt;Search&gt;: render
&lt;SearchBox&gt;: shouldComponentUpdate =&gt; true (cursors have changed)
&lt;SearchBox&gt;: render
&lt;Matches&gt;: shouldComponentUpdate =&gt; true (cursors have changed)
&lt;Matches&gt;: render
&lt;Match key=match-Backbone.js&gt;: shouldComponentUpdate =&gt; false
&lt;Match key=match-Omniscient&gt;: shouldComponentUpdate =&gt; false
&lt;Match key=match-Underscore&gt;: shouldComponentUpdate =&gt; false
&lt;Match key=match-Moment&gt;: shouldComponentUpdate =&gt; false
</code></pre>

<p>We see that all the “top” components are re-rendered (<code>Search</code>, <code>SearchBox</code> and <code>Matches</code>). What is interesting is that not all of the <code>Match</code> components are re-rendering. While <code>Matches</code> re-renders, it removes several elements that doesn’t match our query. The libraries that do match our query are considered for re-rendering but, as they haven’t changed, they don’t actually re-render - they just remain from the previous render.</p>

<p>If we remove a letter from the search query (making it <code>e</code> again), the debug-output for the <code>Match</code> component show:</p>

<pre><code>&lt;Match key=match-Backbone.js&gt;: shouldComponentUpdate =&gt; false
&lt;Match key=match-jQuery&gt;: render
&lt;Match key=match-Prototype&gt;: render
&lt;Match key=match-React&gt;: render
&lt;Match key=match-Omniscient&gt;: shouldComponentUpdate =&gt; false
&lt;Match key=match-Ember&gt;: render
&lt;Match key=match-Mootools&gt;: render
&lt;Match key=match-Underscore&gt;: shouldComponentUpdate =&gt; false
&lt;Match key=match-Moment&gt;: shouldComponentUpdate =&gt; false
&lt;Match key=match-Express&gt;: render
</code></pre>

<p>We can see that all the components that matched the previous query are still there, unchanged, and only the new components get rendered.</p>

<h2 id="summary">Summary</h2>

<p>This has been a introductory tutorial for how we can use Omniscient and React to make applications. The application we created in this tutorial was fairly naive and doesn’t face all the problems of real life use-cases. It is very rare we can have code as clean and small as this, but this shows, at the most basic level, how we can reason about a component based, top-down rendered, efficient UI.</p>

<p>It can be challenging at first to switch out our “traditional” way of designing JavaScript software, and having a loop that iterates every time we make a small change. It also might seem like this would be slow and suboptimal, by far, but the smart implementation of React and the reference checks of Omniscient and Immutable.js will actually allow us to create fast, responsive applications. You can see more <a href="https://github.com/omniscientjs/omniscientjs.github.io/tree/master/examples">example source codes on Github</a> or <a href="http://omniscientjs.github.io/examples">try them out on the Omniscient homepage</a>. On the Omniscient homepage, you can also see how the immutable structure state is changing over the course of the application in real time.</p>

<p>If you have any comments on this architecture, think this is a horrible idea, or simply have questions about Omniscient, you can reach out on <a href="https://github.com/omniscientjs/omniscient/issues">Github issues</a> or ping us at Twitter: <a href="https://twitter.com/mikaelbrevik">@mikaelbrevik</a> and <a href="https://twitter.com/torgeir">@torgeir</a>.</p>

<div class="docs-prevnext">
  
  
  

    <a class="docs-prev" href="/tutorials/01-editing-basic-tutorial-creating-list-with-live-filtering">&larr; Prev</a>
  
  
  
</div>

      </section>
    </main>
    <a href="https://github.com/omniscientjs/" class="link--github">Fork on Github</a>
  </body>
</html>